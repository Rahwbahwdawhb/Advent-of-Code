Very slow solution for part 2, but it does the job
Building the dictionary that handles key press mappings between iterations is what takes time

main idea: evaluate A-strings separately => can represent as dictionaries and see how numbers change
-need to have a dictionary of how each A-string generates other A-strings during an iteration

a bit involved to set up dictionaries for movement on numeric and directional keypads

found solution by manually adjusting iterations for filtering the spawn dict

innan sortering ta 1a värdet

key to filter successively with increased iterations to not take excessive time

it_dict, för alla möjliga paths:
kolla hur sträng utvecklas från en iteration till nästa
såg att lika långa strängar 1a iterationen kunde ge mkt längre nästa
anv för att verifiera då räknar karaktärer

lite wild goose chase att titta på riktningsändringar i sträng
-det viktiga är hur många som genereras i nästa iteration

tricky:
differences between key combinations not evident before several iterations
-difficult to remove
-the shortest path for a higher iteration number did in general not come from the
 same start key combination obtained from the numeric dict




def get_paths_2(possible_paths,move_dict,move):
    new_paths=[]
    minimum_moves=move_dict[move][0][0]
    while possible_paths:
        move_str=possible_paths.pop()
        for moves_,path_ in move_dict[move]:
            if moves_==minimum_moves:
                new_paths.append(move_str+path_+'A')
    return new_paths

A_str=it_dicts[0][possible_paths[0]][0]
new_move_str=''
for i in range(len(A_str)-1):
    new_move_str+=directional_dict[A_str[i:i+1+1]][0][1]+'A'
print(('A'+new_move_str)==it_dicts[1][A_str][0])
print(('A'+new_move_str))
print(it_dicts[1][A_str][0])

387278
1:1,2,1
2:1,25,1

23

bör ha rätt upp till 3 iterationer

är minmoves=minst steg eller minst riktningsändringar?
move_dict har lista av vägar m minst drag sorterade efter minst riktningsändringar

pga börjar från A å ska tillbaka till A för att göra move
=>kommer ta minst antal steg till knapp (från A) 2 ggr

ex tryck 2
numeric: 2
dir 1: <^A
dir 2: v<<A >^A >A
dir 3: v<A <A A >>^A vA <^A >A vA ^A
dir 4: v<A <A >>^A v<<A >>^A A vA A <^A >A v<A >^A v<<A >^A >A vA ^A v<A >^A <A >A

A<^A => Av<<A,A>^A,A>A
Av<<A => Av<A,A<A,AA,A>>^A,AvA,A<^A,A>A,AvA,A^A
bör kunna ta reda på alla A->A-kombinationer, dessa bör kunna räknas individuellt
-kan då bara räkna antal i 1a sträng, använda dictionary för att räkna ut antal efter varje iteration!
1. kör alla kombinationer av A->nummerknapp->A
2. separera outputs i A-pilar-A par
3. ge dessa som inputs till direction dictionary
4. kolla om får nya A-pilar-A inputs, kör i sånt fall även dessa
5. för varje A-pilar-A inputs till directional dict, räkna antal av oika A-pilar-A snippets som genereras
6. gör iterations-map-dictionary m alla A-pilar-A strängar från ovan
7. för varje iteration behöver subtrahera "extra A" eftersom varje A räknas i 2 par (början och slut) samt A i början av sträng för startposition
   -borde få rätt om dividerar antal A i alla par med 2, med start A blir som att räknar varje A 2 ggr...

0,0
1,1
2,spelar ej roll
3,0 -finns 4 möjliga från 1a

Av<A,A<A,AA,A>>^A,AVA,A<^A,A>A,

Av => v<A
v< => <A
<A => >>^A
A< => v<<A
AA => A
A> => vA
>> => A
>^ => <^A
^A => >A
vA => >^A
<^ => >^A
>A => ^A
A^ => <A
v< => <A
<< => A
^< => v<A

**
om splittar 'A<^AvA^^^A>vvvA' => ['', '<^', 'v', '^^^', '>vvv', '']
-prob att kört [1:] tidigare? eller var innan hade 1:a A?

kolla att dict blir samma om ej sparar iterationer då N=2

hur nästa sträng ser ut beror på följd av karaktärer, ej bara vilka karakätärer som ingår
=> bör ej bara kunna identifiera ex antal Av och mappa till antal v<A i nästa sträng
-för det säger ej ngt om var nånstans de kommer att sitta å därmed ej ge tillräcklig bild för nästa iteration
--använd dictionary från directional dict -> directional dict för att iterativt bygga på sträng då loopar igenom
---problem med för lång sträng?

ovanför dir 1:  v<< A >>^ A
ovanför dir2: v< A ^> A 

+---+---+---+
| 7 | 8 | 9 |
+---+---+---+
| 4 | 5 | 6 |
+---+---+---+
| 1 | 2 | 3 |
+---+---+---+
    | 0 | A |
    +---+---+

    +---+---+
    | ^ | A |
+---+---+---+
| < | v | > |
+---+---+---+

rangordna riktningar utifrån att kommer från A
och ska till A för directional_dict?




directional_input=it_dicts[1][list(it_dicts[1].keys())[0]][0]
all_possible_paths_iter=['A']
for i in range(len(directional_input)-1):
    move=directional_input[i]+directional_input[i+1]
    all_possible_paths_iter=get_paths_2(all_possible_paths_iter,directional_dict,move)
mm=[10**18,0]
for pp in all_possible_paths_iter:
    NN=len(pp)
    if NN<mm[0]:
        mm[0]=NN
    if NN>mm[1]:
        mm[1]=NN
print(mm)

verkar som om väljer den som ger kortast sträng efter 1a directional propagation
fortsätter ge kortast..iaf upp till 3:e

hitta dict_mapping som ger samma utsträng som om kör get_path!



